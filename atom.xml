<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>web</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-08-13T13:36:26.561Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>knife</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>详谈JavaScript中的闭包</title>
    <link href="http://yoursite.com/2017/08/13/%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2017/08/13/闭包/</id>
    <published>2017-08-13T13:36:55.332Z</published>
    <updated>2017-08-13T13:36:26.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="闭包的定义"><a href="#闭包的定义" class="headerlink" title="闭包的定义"></a>闭包的定义</h1><p>有不少的学习者总是将<strong>闭包</strong>和<strong>匿名函数</strong>搞混，认为匿名函数就是闭包；其实匿名函数是一个概念：有权访问另一个函数作用域中的变量的函数；</p>
<h2 id="1、回顾"><a href="#1、回顾" class="headerlink" title="1、回顾"></a>1、回顾</h2><p>前面我介绍了垃圾回收和作用域的概念，不清楚的可以看下我前面的文章，当一个函数执行完毕其当前的函数作用域就会释放，为了后面可以访问该函数作用域中的变量，我们将使用闭包，先介绍一个例子：<br></p>
<pre><code>function sum () {
    var a = 10,
        b = 20;
    return function (c) {
        return a + b + c;
    }
}
var add = sum();
document.writeln(add(1));    //31
</code></pre><p>在这个例子中，在内部函数（匿名函数）中，访问了外部函数中的变量a、b,当这个函数返回的时候，在其他地方被调用，仍然可以访问到这两个变量，因为，内部函数的作用域链包含sum()的作用域；由此可见对于作用域链的了解对闭包的学习至关重要，当某个函数被调用的时候，会创建一个执行环境和相应的作用域链，用arguments和其他命名参数的值来初始化函数的活动对象，在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，这样一直到作为终点的全局执行环境；</p>
<h2 id="2、使用闭包"><a href="#2、使用闭包" class="headerlink" title="2、使用闭包"></a>2、使用闭包</h2><p>在很多才开始学习的人对闭包并不能理解，为什么要访问其他函数作用域中的东西，我将要用到的东西全部放在全局作用域不就可以了？这就涉及了全局变量特性的弊端了；</p>
<h3 id="2-1、全局变量-一个糟糕的依赖"><a href="#2-1、全局变量-一个糟糕的依赖" class="headerlink" title="2.1、全局变量(一个糟糕的依赖)"></a>2.1、全局变量(一个糟糕的依赖)</h3><p>全局变量就是在所有作用域中都可见的变量。在开始的时候会带来方便，但是当程序变得越来越复杂的时候，它们将变得难以管理，因为它们在程序的任何部分的任何时间修改，降低了程序的可靠性，全局变量使得同一个程序中的独立子程序运行出错，因为全局变量中的变量恰好等于子程序中的变量时，就会相互冲突；</p>
<h3 id="2-2、拥有自己的私有变量"><a href="#2-2、拥有自己的私有变量" class="headerlink" title="2.2、拥有自己的私有变量"></a>2.2、拥有自己的私有变量</h3><pre><code>function hello (name) {
    return function () {
        alert(&quot;hello &quot;+ name + &quot;!&quot;);
    }
}
var sayhello = hello(&quot;Jack&quot;);
sayhello();    //hello Jack!
</code></pre><p>只有通过sayhello()访问到hello函数中的name变量，因为hello()执行完毕后其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中，因为匿名函数的作用域链仍然在引用这个活动对象，私有这个概念对创建保护隐私的对象中很有用； </p>
<h3 id="2-3、糟糕的例子"><a href="#2-3、糟糕的例子" class="headerlink" title="2.3、糟糕的例子"></a>2.3、糟糕的例子</h3><p>这里我们需要理解的是，内部函数能访问到外部函数的实际变量而无须复制是很重要的；</p>
<pre><code>var addEvents = function (targets) {
    var i,
        len;
    for (i = 0, len = targets.length; i &lt; len; i +=1) {
        targets[i].onclick = function (e) {
            alert(i);    //总会弹出总节点的数目
        }    
    }
};
</code></pre><p>上面结果出现时因为：当进入循环的时候，i递增且按顺序给节点绑定点击事件和处理函数，此时并不会马上执行事件处理函数，当全部节点都绑定了事件的时候，i的值已经增加为节点的数目，此时点击事件触发的时候，处理函数在它的内部找不到变量i就会沿着作用域链向上查找到addEvent中的变量i，但是i已经递增到了节点数量。<br><strong>解决方法</strong>：直接调用函数，或则将i保存在其他地方，改进(避免在循环中创建函数)后：</p>
<pre><code>var addEvents = function (targets) {
    var i,
        len;
    var handlers = function (i) {
        return function (e) {
            alert(i);
        };    
    };
    for (i = 0, len = targets.length; i &lt; len; i += 1) {
        target[i].onclick = handlers (i);
    }

}
var addEvents = function (targets) {
    var i,
        len;
    for (i = 0, len = targets.length; i &lt; len; i += 1)    {
        (function (i) {
            target[i].onclick = function (e) {
                alert (i);
            }
        })(i)
    }
}
</code></pre><p>闭包是个很强大的功能，这里只是对他进行一个简单的介绍，大家需要记住闭包就是有权访问另一个函数作用域中的变量的函数，我们可以用闭包做出很多的功能，更多的知识后面我会补充给大家。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;闭包的定义&quot;&gt;&lt;a href=&quot;#闭包的定义&quot; class=&quot;headerlink&quot; title=&quot;闭包的定义&quot;&gt;&lt;/a&gt;闭包的定义&lt;/h1&gt;&lt;p&gt;有不少的学习者总是将&lt;strong&gt;闭包&lt;/strong&gt;和&lt;strong&gt;匿名函数&lt;/strong&gt;搞混，认为匿名
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学习作用域</title>
    <link href="http://yoursite.com/2017/07/26/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2017/07/26/作用域/</id>
    <published>2017-07-26T14:09:54.962Z</published>
    <updated>2017-07-26T14:15:05.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="javascript的作用域"><a href="#javascript的作用域" class="headerlink" title="javascript的作用域"></a>javascript的作用域</h1><p>为了后面介绍的<strong>闭包</strong>，我先在这里介绍JavaScript中的作用域，作用域控制着变量与参数的可见性和生命周期。<br><br>JavaScript的一个重要的概念就是<strong>执行环境</strong>，每个执行环境都有一个与之相关的变量对象，环境中定义的所有变量和函数都保存在这个对象中；其中最外围的执行环境是全局执行环境，在web浏览器中，全局执行环境被认为是window对象，所有全局变量和函都作为window对象的属性和方法创建的，所以全局中的函数内部的this指向的是window（万事不是绝对的，也可以通过call()和aplly()方法改变this的指向，这里就不做详细的介绍，知道全局中的函数this可以改变指向就可以了，默认情况指向window）<br></p>
<pre><code>function test(){
    alert(this);    
}
test();   //window对象
</code></pre><p>每个函数都有自己的执行环境，当执行某个函数的时候，函数的环境会推入一个环境栈中，函数执行完毕后，栈将其环境弹出，把控制权返回给之前的执行环境。<br><br>当代码进入一个环境中执行时，会创建变量对象的一个<strong>作用域链</strong>，其作用是保证对执行环境有权访问的所有变量和函数的有序访问。作用域的前端是当前正在执行代码所在的环境变量对象；其工作机制是向上查找机制，意思是在当前代码执行环境中找不到要求的变量和函数就会向其包含(外部)环境中查找，如果还是没有就向外部的外部环境中查找，以此类推一直找到window对象，只要找到就停止向上查找，注意不能反向查找；</p>
<pre><code>//向上查找机制
var age = 30;
var sex = &quot;男&quot;;
function person(){
    name = &quot;小明&quot;；
    var age = 18;
    console.log(age); 
    console.log(sex);
}
person();  //18  男
console.log(name); //小明
</code></pre><p>上面的代码可以看出，当执行person的时候，执行环境时函数，在内部查找有age变量，所以停止向上查找打印全局中的age变量的值，而sex在函数环境中没有，根据作用域向上查找到window对象中的sex变量的值并打印，相信都注意到最后一行的代码了，这里我是在全局中打印name变量，按理来说我并没有在全局中定义这个变量，为什么不是undefined呢？仔细看person函数内部定义了变量name但是没有使用关键字var，这样定义的变量会直接定义在全局中，使全局也可以使用这个变量，但是不建议大家使用，过度使用会造成污染全局变量，并且在严格模式下这样会导致错误；<br><br><strong>在JavaScript中没有块级作用域</strong>，只有函数作用域，在其他类的C语言中，由花括号封闭的代码都有自己的作用域，所以在JavaScript中if和for语句定义的变量在其运行完毕后仍然存在，他们定义的变量添加到了当前的执行环境中，而在函数内部定义的变量，在函数内部的任何地方都可见；</p>
<pre><code>//没有块级作用域
for (var i = 0; i &lt; 10; i++){
    //运行相应的代码
}
alert(i);  //10
</code></pre><p><strong>注意</strong>：由于JavaScript没有块级作用域，所以推荐在函数体的顶部定义所有的变量。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;javascript的作用域&quot;&gt;&lt;a href=&quot;#javascript的作用域&quot; class=&quot;headerlink&quot; title=&quot;javascript的作用域&quot;&gt;&lt;/a&gt;javascript的作用域&lt;/h1&gt;&lt;p&gt;为了后面介绍的&lt;strong&gt;闭包&lt;/str
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript的垃圾回收</title>
    <link href="http://yoursite.com/2017/06/30/%E5%9E%83%E5%9C%BE%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2017/06/30/垃圾处理机制/</id>
    <published>2017-06-30T13:35:37.127Z</published>
    <updated>2017-06-30T14:54:55.069Z</updated>
    
    <content type="html"><![CDATA[<h1 id="js中的垃圾回收机制"><a href="#js中的垃圾回收机制" class="headerlink" title="js中的垃圾回收机制"></a>js中的垃圾回收机制</h1><p>和其他的C、C++之类的语言不同，js具有自动垃圾收集机制，其原理大致是：按照固定的时间间隔周期性的找出那些不需要再使用的的变量，将它所占用的内存释放。例如局部变量，一旦函数结束，局部变量就没有存在必要了，可以释放它们占用的内存。貌似很简单的工作，为什么会有很大开销呢？这仅仅是垃圾回收的冰山一角，就像闭包，貌似函数结束了，其实还没有，垃圾回收器必须知道哪个变量有用，哪个变量没用，对于不再有用的变量打上标记，以备将来回收。用于标记无用的策略有很多，常见的有两种方式</p>
<h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>在js中最常用的垃圾收集方式就是<strong>标记清除</strong>，其工作方式是：当一个变量进入环境时，将其标记为<strong>进入环境</strong>（可以使用很多方式来进行标记，例如翻转某个特殊位来记录，或者使用一个“进入环境”的变量列表和“离开环境”的变量列表来跟踪变量的变化），如何标记并不重要，关键是采用什么策略；</p>
<p>垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量，在这些完成之后仍存在标记的就是要删除的变量了，因为环境中的变量已经无法访问到这些变量了，然后垃圾回收器相会这些带有标记的变量机器所占空间；低版本的ie采用第二种垃圾收集策略；</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p><strong>引用计数</strong>的含义就是跟踪记录每个值被引用的次数，当声明了一个变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。</p>
<p>很快就遇到了很严重的问题<strong>循环引用</strong>：对象A中包含一个指向对象B的指针，而对象B也包含一个指向对象A的指针，如下所示：</p>
<pre><code>function test(){
    var objA = new object();
    var objB = new object();
    objA.someObject = objB;
    objB.anotherObject = objA;
}
</code></pre><p>上面的两个对象通过各自的属性相互引用（次数都是2）；在标记清除的策略中没问题，在引用计数时，函数执行完毕后，两个对象仍然继续存在，因为他们的次数永远不为0；大家都知道，IE中有一部分对象并不是原生js对象，COM对象（BOM和DOM）就是采用引用计数，所以在IE中涉及到COM对象就存在循环引用问题，如下：</p>
<pre><code>var    element = document.getElementById(&quot;element&quot;);
var obj = {};
element.obj1 = obj;
obj.element = elememt;
</code></pre><p>既然出现了问题就会有相应的解决方法，最好是在不使用它们的时候手动断开原生js对象与DOM对象之间的连接，如下：</p>
<pre><code>element.obj1 = null;
obj.element = null;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;js中的垃圾回收机制&quot;&gt;&lt;a href=&quot;#js中的垃圾回收机制&quot; class=&quot;headerlink&quot; title=&quot;js中的垃圾回收机制&quot;&gt;&lt;/a&gt;js中的垃圾回收机制&lt;/h1&gt;&lt;p&gt;和其他的C、C++之类的语言不同，js具有自动垃圾收集机制，其原理大致是：按
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript中的对象</title>
    <link href="http://yoursite.com/2017/06/15/%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2017/06/15/对象的简介/</id>
    <published>2017-06-15T13:10:11.694Z</published>
    <updated>2017-06-16T04:42:35.728Z</updated>
    
    <content type="html"><![CDATA[<p>2017/6/12 21:37:26 </p>
<h2 id="对象的简介"><a href="#对象的简介" class="headerlink" title="对象的简介"></a>对象的简介</h2><p><strong>JavaScript</strong>是一门面向对象的语言，面向对象的标志是有类的概念，通过类可以创建任意多个具有相同属性和方法的对象。<strong>ECMA-262</strong>将对象定义为“无序属性的集合，其属性可以包含基本值、对象或者函数。”我的理解是对象就是一些属性和方法组合在一起而构成的一个数据实体。</p>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><h3 id="1、创建一个Object实例"><a href="#1、创建一个Object实例" class="headerlink" title="1、创建一个Object实例"></a>1、创建一个Object实例</h3><pre><code>//创建实例，返回的引用保存在一个变量中，相当于c中的指针，指向创建的实例
  var person = new Object();
//添加实例和方法
  person.name = &quot;Rose&quot;;
  person.age = 19;
  person.sayhello = function(){
      alert(&quot;hello&quot; + this.name);
  } 
//使用对象点属性名  
  alert(person.name)        //Rose
</code></pre><h3 id="2、使用对象字面量"><a href="#2、使用对象字面量" class="headerlink" title="2、使用对象字面量"></a>2、使用对象字面量</h3><pre><code>//将所有属性和方法放在方括号内，使用逗号分开，属性名的引号可有可无
 var person = {
    name: &quot;Rose&quot;,
    age: 19,
    sayhello: function(){
      alert(&quot;hello&quot; + this.name);
    }
 };
</code></pre><h3 id="3、构造函数模式"><a href="#3、构造函数模式" class="headerlink" title="3、构造函数模式"></a>3、构造函数模式</h3><p>还有<strong>工厂模式</strong>（用函数来封装以特定借口创建对象的细节），但由于没有解决对象识别的问题，不建议使用，故此处不做详细介绍，提出的解决对象识别的方法是构造函数模式；</p>
<pre><code>function Person(name, age){
    this.name = name;
    this.age = age;
    this.sayhello = function(){
        alert(this);
    }
}
//使用new调用构造函数返回一个Person实例
var person = new Person(&quot;Rose&quot;, 19);
</code></pre><p>代码中可以看出，与普通的函数没多大区别，其中的this为调用构造函数的对象（person），构造函数模式创建的对象拥有自己的原生构造函数，实例的cunstructor属性返回构造函数，obj instanceof object 判断是否是某个的实例</p>
<h3 id="4、原型的引入"><a href="#4、原型的引入" class="headerlink" title="4、原型的引入"></a>4、原型的引入</h3><p>上面的介绍的构造函数有一定的缺陷，就是每个方法在每个实例上重新创建一次，这样就会降低性能。我们所创建的<strong>函数</strong>都有一个prototype属性，该属性指向一个对象,包含所有特定类型实例共享的属性和方法。 </p>
<pre><code>function Person(){}
 Person.prototype.name = 19;
 Person.prototype.sayhellp = function(){
    alert(this.name);    
};
</code></pre><p>注意必须是<strong>构造函数创建的对象</strong>才能使用prototype属性处理原型，如用对象字面量就不能使用；<strong>注意</strong>：如果直接给Person.prototype是<br><strong>重写原型操作</strong>，将切断现有原型与任何之前已经存在的对象实例之间的联系，它们引用的仍然是最初的原型。简而言之就是，在创建一个实例后再重写原型，这个实例仍然指向重写前的原型；<br>最好将原型模式和构造函数模式结合起来使用，使创建的每个实例既有自己独有的属性，又有公有属性；</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>原型链作为实现继承的主要方法，利用原型链让一个引用类型继承另一个引用类型的属性和方法，实现的本质是重写原型链，将一个实例赋给一个构造函数的原型；下面是<em>组合继承</em>：</p>
<pre><code>function Super(name){
    this.name = name;
}
Super.prototype.sayname = function(){
    alert(this.name);
}
function Sub(name， age){
//在Sub环境中调用Super构造函数，并有自己的属性age
    Super.call(this, name);
    this.age = age;
}
//将Suoer实例赋给Sub的原型
Sub.prototype = new Super();
//增强原型，重写后的原型需要重新指向构造函数
Sub.prototype.constructor = Sub;
</code></pre><p><strong>总结</strong>：上面只是对如何简单的创建对象进行了一个介绍，在实际工作中，每个方法都有用，要根据你实际的情况选择，或许你会觉得将原型没有什么用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017/6/12 21:37:26 &lt;/p&gt;
&lt;h2 id=&quot;对象的简介&quot;&gt;&lt;a href=&quot;#对象的简介&quot; class=&quot;headerlink&quot; title=&quot;对象的简介&quot;&gt;&lt;/a&gt;对象的简介&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;JavaScript&lt;/strong&gt;是一门面
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/05/20/hello-world/"/>
    <id>http://yoursite.com/2017/05/20/hello-world/</id>
    <published>2017-05-20T11:15:39.565Z</published>
    <updated>2017-05-20T11:15:39.566Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
