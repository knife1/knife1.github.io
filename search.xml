<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[学习作用域]]></title>
      <url>/2017/07/26/%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      <content type="html"><![CDATA[<h1 id="javascript的作用域"><a href="#javascript的作用域" class="headerlink" title="javascript的作用域"></a>javascript的作用域</h1><p>为了后面介绍的<strong>闭包</strong>，我先在这里介绍JavaScript中的作用域，作用域控制着变量与参数的可见性和生命周期。<br><br>JavaScript的一个重要的概念就是<strong>执行环境</strong>，每个执行环境都有一个与之相关的变量对象，环境中定义的所有变量和函数都保存在这个对象中；其中最外围的执行环境是全局执行环境，在web浏览器中，全局执行环境被认为是window对象，所有全局变量和函都作为window对象的属性和方法创建的，所以全局中的函数内部的this指向的是window（万事不是绝对的，也可以通过call()和aplly()方法改变this的指向，这里就不做详细的介绍，知道全局中的函数this可以改变指向就可以了，默认情况指向window）<br></p>
<pre><code>function test(){
    alert(this);    
}
test();   //window对象
</code></pre><p>每个函数都有自己的执行环境，当执行某个函数的时候，函数的环境会推入一个环境栈中，函数执行完毕后，栈将其环境弹出，把控制权返回给之前的执行环境。<br><br>当代码进入一个环境中执行时，会创建变量对象的一个<strong>作用域链</strong>，其作用是保证对执行环境有权访问的所有变量和函数的有序访问。作用域的前端是当前正在执行代码所在的环境变量对象；其工作机制是向上查找机制，意思是在当前代码执行环境中找不到要求的变量和函数就会向其包含(外部)环境中查找，如果还是没有就向外部的外部环境中查找，以此类推一直找到window对象，只要找到就停止向上查找，注意不能反向查找；</p>
<pre><code>//向上查找机制
var age = 30;
var sex = &quot;男&quot;;
function person(){
    name = &quot;小明&quot;；
    var age = 18;
    console.log(age); 
    console.log(sex);
}
person();  //18  男
console.log(name); //小明
</code></pre><p>上面的代码可以看出，当执行person的时候，执行环境时函数，在内部查找有age变量，所以停止向上查找打印全局中的age变量的值，而sex在函数环境中没有，根据作用域向上查找到window对象中的sex变量的值并打印，相信都注意到最后一行的代码了，这里我是在全局中打印name变量，按理来说我并没有在全局中定义这个变量，为什么不是undefined呢？仔细看person函数内部定义了变量name但是没有使用关键字var，这样定义的变量会直接定义在全局中，使全局也可以使用这个变量，但是不建议大家使用，过度使用会造成污染全局变量，并且在严格模式下这样会导致错误；<br><br><strong>在JavaScript中没有块级作用域</strong>，只有函数作用域，在其他类的C语言中，由花括号封闭的代码都有自己的作用域，所以在JavaScript中if和for语句定义的变量在其运行完毕后仍然存在，他们定义的变量添加到了当前的执行环境中，而在函数内部定义的变量，在函数内部的任何地方都可见；</p>
<pre><code>//没有块级作用域
for (var i = 0; i &lt; 10; i++){
    //运行相应的代码
}
alert(i);  //10
</code></pre><p><strong>注意</strong>：由于JavaScript没有块级作用域，所以推荐在函数体的顶部定义所有的变量。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript的垃圾回收]]></title>
      <url>/2017/06/30/%E5%9E%83%E5%9C%BE%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h1 id="js中的垃圾回收机制"><a href="#js中的垃圾回收机制" class="headerlink" title="js中的垃圾回收机制"></a>js中的垃圾回收机制</h1><p>和其他的C、C++之类的语言不同，js具有自动垃圾收集机制，其原理大致是：按照固定的时间间隔周期性的找出那些不需要再使用的的变量，将它所占用的内存释放。例如局部变量，一旦函数结束，局部变量就没有存在必要了，可以释放它们占用的内存。貌似很简单的工作，为什么会有很大开销呢？这仅仅是垃圾回收的冰山一角，就像闭包，貌似函数结束了，其实还没有，垃圾回收器必须知道哪个变量有用，哪个变量没用，对于不再有用的变量打上标记，以备将来回收。用于标记无用的策略有很多，常见的有两种方式</p>
<h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>在js中最常用的垃圾收集方式就是<strong>标记清除</strong>，其工作方式是：当一个变量进入环境时，将其标记为<strong>进入环境</strong>（可以使用很多方式来进行标记，例如翻转某个特殊位来记录，或者使用一个“进入环境”的变量列表和“离开环境”的变量列表来跟踪变量的变化），如何标记并不重要，关键是采用什么策略；</p>
<p>垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量，在这些完成之后仍存在标记的就是要删除的变量了，因为环境中的变量已经无法访问到这些变量了，然后垃圾回收器相会这些带有标记的变量机器所占空间；低版本的ie采用第二种垃圾收集策略；</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p><strong>引用计数</strong>的含义就是跟踪记录每个值被引用的次数，当声明了一个变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。</p>
<p>很快就遇到了很严重的问题<strong>循环引用</strong>：对象A中包含一个指向对象B的指针，而对象B也包含一个指向对象A的指针，如下所示：</p>
<pre><code>function test(){
    var objA = new object();
    var objB = new object();
    objA.someObject = objB;
    objB.anotherObject = objA;
}
</code></pre><p>上面的两个对象通过各自的属性相互引用（次数都是2）；在标记清除的策略中没问题，在引用计数时，函数执行完毕后，两个对象仍然继续存在，因为他们的次数永远不为0；大家都知道，IE中有一部分对象并不是原生js对象，COM对象（BOM和DOM）就是采用引用计数，所以在IE中涉及到COM对象就存在循环引用问题，如下：</p>
<pre><code>var    element = document.getElementById(&quot;element&quot;);
var obj = {};
element.obj1 = obj;
obj.element = elememt;
</code></pre><p>既然出现了问题就会有相应的解决方法，最好是在不使用它们的时候手动断开原生js对象与DOM对象之间的连接，如下：</p>
<pre><code>element.obj1 = null;
obj.element = null;
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript中的对象]]></title>
      <url>/2017/06/15/%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>2017/6/12 21:37:26 </p>
<h2 id="对象的简介"><a href="#对象的简介" class="headerlink" title="对象的简介"></a>对象的简介</h2><p><strong>JavaScript</strong>是一门面向对象的语言，面向对象的标志是有类的概念，通过类可以创建任意多个具有相同属性和方法的对象。<strong>ECMA-262</strong>将对象定义为“无序属性的集合，其属性可以包含基本值、对象或者函数。”我的理解是对象就是一些属性和方法组合在一起而构成的一个数据实体。</p>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><h3 id="1、创建一个Object实例"><a href="#1、创建一个Object实例" class="headerlink" title="1、创建一个Object实例"></a>1、创建一个Object实例</h3><pre><code>//创建实例，返回的引用保存在一个变量中，相当于c中的指针，指向创建的实例
  var person = new Object();
//添加实例和方法
  person.name = &quot;Rose&quot;;
  person.age = 19;
  person.sayhello = function(){
      alert(&quot;hello&quot; + this.name);
  } 
//使用对象点属性名  
  alert(person.name)        //Rose
</code></pre><h3 id="2、使用对象字面量"><a href="#2、使用对象字面量" class="headerlink" title="2、使用对象字面量"></a>2、使用对象字面量</h3><pre><code>//将所有属性和方法放在方括号内，使用逗号分开，属性名的引号可有可无
 var person = {
    name: &quot;Rose&quot;,
    age: 19,
    sayhello: function(){
      alert(&quot;hello&quot; + this.name);
    }
 };
</code></pre><h3 id="3、构造函数模式"><a href="#3、构造函数模式" class="headerlink" title="3、构造函数模式"></a>3、构造函数模式</h3><p>还有<strong>工厂模式</strong>（用函数来封装以特定借口创建对象的细节），但由于没有解决对象识别的问题，不建议使用，故此处不做详细介绍，提出的解决对象识别的方法是构造函数模式；</p>
<pre><code>function Person(name, age){
    this.name = name;
    this.age = age;
    this.sayhello = function(){
        alert(this);
    }
}
//使用new调用构造函数返回一个Person实例
var person = new Person(&quot;Rose&quot;, 19);
</code></pre><p>代码中可以看出，与普通的函数没多大区别，其中的this为调用构造函数的对象（person），构造函数模式创建的对象拥有自己的原生构造函数，实例的cunstructor属性返回构造函数，obj instanceof object 判断是否是某个的实例</p>
<h3 id="4、原型的引入"><a href="#4、原型的引入" class="headerlink" title="4、原型的引入"></a>4、原型的引入</h3><p>上面的介绍的构造函数有一定的缺陷，就是每个方法在每个实例上重新创建一次，这样就会降低性能。我们所创建的<strong>函数</strong>都有一个prototype属性，该属性指向一个对象,包含所有特定类型实例共享的属性和方法。 </p>
<pre><code>function Person(){}
 Person.prototype.name = 19;
 Person.prototype.sayhellp = function(){
    alert(this.name);    
};
</code></pre><p>注意必须是<strong>构造函数创建的对象</strong>才能使用prototype属性处理原型，如用对象字面量就不能使用；<strong>注意</strong>：如果直接给Person.prototype是<br><strong>重写原型操作</strong>，将切断现有原型与任何之前已经存在的对象实例之间的联系，它们引用的仍然是最初的原型。简而言之就是，在创建一个实例后再重写原型，这个实例仍然指向重写前的原型；<br>最好将原型模式和构造函数模式结合起来使用，使创建的每个实例既有自己独有的属性，又有公有属性；</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>原型链作为实现继承的主要方法，利用原型链让一个引用类型继承另一个引用类型的属性和方法，实现的本质是重写原型链，将一个实例赋给一个构造函数的原型；下面是<em>组合继承</em>：</p>
<pre><code>function Super(name){
    this.name = name;
}
Super.prototype.sayname = function(){
    alert(this.name);
}
function Sub(name， age){
//在Sub环境中调用Super构造函数，并有自己的属性age
    Super.call(this, name);
    this.age = age;
}
//将Suoer实例赋给Sub的原型
Sub.prototype = new Super();
//增强原型，重写后的原型需要重新指向构造函数
Sub.prototype.constructor = Sub;
</code></pre><p><strong>总结</strong>：上面只是对如何简单的创建对象进行了一个介绍，在实际工作中，每个方法都有用，要根据你实际的情况选择，或许你会觉得将原型没有什么用。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/05/20/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
